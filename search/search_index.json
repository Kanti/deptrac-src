{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#what-is-deptrac","title":"What is Deptrac?","text":"<p>Deptrac is a static code analysis tool for PHP that helps you communicate, visualize and enforce architectural decisions in your projects. You can freely define your architectural layers over classes and which rules should apply to them.</p> <p>For example, you can use Deptrac to ensure that bundles/modules/extensions in your project are truly independent of each other to make them easier to reuse.</p> <p>Deptrac can be used in a CI pipeline to make sure a pull request does not violate any of the architectural rules you defined. With the optional Graphviz formatter you can visualize your layers, rules and violations.</p> <p></p>"},{"location":"#requirements","title":"Requirements","text":"<p>In order to run Deptrac you need at least PHP 8.1.</p> <p>You can analyse projects that require an older PHP version as long as nikic/php-parser can parse it.</p>"},{"location":"#installation","title":"Installation","text":"<p>You can install Deptrac via Composer. We recommend using the deptrac-shim package for this. Alternatively, you can also use PHIVE or download the PHAR attached to each release on GitHub. This will ensure that Deptrac and its dependencies are bundled together and will not interfere with any of your project's dependencies.</p>"},{"location":"#composer","title":"Composer","text":"<p>We strongly advise against using the deptrac package directly as a composer dependency. We update dependencies regularly, which might cause disruptions in your project. Instead, please use the dedicated distribution repository https://github.com/qossmic/deptrac-shim.</p> <p>When you install Deptrac using the qossmic/deptrac-shim package, you will get the benefit of using the phar installation, but you can use it like any other composer dependency, i.e. you run Deptrac like this:</p> <pre><code>$ composer require --dev qossmic/deptrac-shim\nvendor/bin/deptrac analyse\n</code></pre>"},{"location":"#phar","title":"PHAR","text":"<p>Download the latest deptrac.phar.</p> <p>You can run the phar file using php:</p> <pre><code>$ php deptrac.phar analyse\n</code></pre> <p>All examples in this documentation, assume you have the deptrac.phar downloaded in your project's root directory as described above.</p> <p>Feel free to add Deptrac to your PATH (i.e. <code>/usr/local/bin/deptrac</code>) to make it globally available.</p> <pre><code>$ curl -LS https://github.com/qossmic/deptrac/releases/download/1.0.2/deptrac.phar -o deptrac.phar\n\n# optional\n$ sudo chmod +x deptrac.phar\n$ sudo mv deptrac.phar /usr/local/bin/deptrac\n</code></pre>"},{"location":"#phive","title":"PHIVE","text":"<p>You can install Deptrac with Phive</p> <p><code>phive install -g qossmic/deptrac</code></p> <p>and accept the key with fingerprint <code>41DD E075 4745 9FAE CFA1  7813 B8F6 4013 4AB1 782E</code>.</p> <p>To upgrade Deptrac use the following command:</p> <p><code>phive update -g qossmic/deptrac</code></p>"},{"location":"#optional-dependency-graphviz","title":"Optional Dependency: Graphviz","text":"<p>If you want to create graphical diagrams with your class dependencies, you will also need the <code>dot</code> command provided by Graphviz.</p> <p>Graphviz can be installed using common package managers:</p> <pre><code># for macos + brew\n$ brew install graphviz\n\n# for ubuntu and debian\n$ sudo apt-get install graphviz\n</code></pre> <p>Graphviz is also available for Windows. Install the current stable release and append the binary path on the environment variable Path (e.g. <code>C:\\Program Files (x86)\\Graphviz2.38\\bin</code>).</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>In order to get started with Deptrac you will need a configuration file. This configuration file is written in YAML and, by default, is stored with the name <code>deptrac.yaml</code> in your project's root directory.</p> <p>Deptrac can generate a template for you, using the <code>init</code> command.</p> <pre><code>$ php deptrac.phar init\n</code></pre> <p>The main purpose of this file is:</p> <ol> <li>Define in which directories Deptrac will search for classes and which files    to exclude.</li> <li>Define your architectural layers using so-called collectors.</li> <li>Define a ruleset describing which layers can communicate with each other.</li> </ol> <p>You can find out more about the Core Concepts in the docs.</p>"},{"location":"#configuration","title":"Configuration","text":"<p>Let's have a look at the generated file:</p> <pre><code># deptrac.yaml\ndeptrac:\n  paths:\n    - ./src\n  exclude_files:\n    - '#.*test.*#'\n  layers:\n    -\n      name: Controller\n      collectors:\n        -\n          type: classLike\n          value: .*Controller.*\n    -\n      name: Repository\n      collectors:\n        -\n          type: classLike\n          value: .*Repository.*\n    -\n      name: Service\n      collectors:\n        -\n          type: classLike\n          value: .*Service.*\n  ruleset:\n    Controller:\n      - Service\n    Service:\n      - Repository\n    Repository: ~\n</code></pre> <p>By default, Deptrac will search your project's <code>src/</code> directory for classes and will ignore any files and directory having <code>test</code> in it.</p> <p>We then define three layers by searching for class names in the files found by Deptrac. Any file containing a class with <code>Controller</code> will be grouped in a layer with the same name. The same happens for classes having <code>Repository</code> and <code>Service</code> in their name. It is important to note that the fully qualified class name is used for grouping classes. That means, the collector will take the full namespace with class name into account.</p> <p>The default ruleset will then allow classes in the Controller-layer to communicate - i.e. use classes from - the Service layer. Classes grouped in the Service layer may not use classes from the Controller layer, but they can use classes from the Repository layer. Classes inside the Repository layer may not use any classes from the other two layers.</p> <p>You can learn more about the file in the Configuration reference.</p>"},{"location":"#run-deptrac","title":"Run Deptrac","text":"<p>Once you have set up the config file you can run Deptrac to analyse your code and check for violations. If you use the default configuration file, you can type <code>php deptrac.phar</code>, otherwise you will need to specify which command and config file should be used.</p> <pre><code>$ php deptrac.phar\n\n# which is equivalent to\n$ php deptrac.phar analyse --config-file=deptrac.yaml\n</code></pre> <p>If you run <code>php deptrac.phar -v</code> you'll get a more verbose output.</p> <p>The analyse command runs with a caching mechanism for parsed files by default. This can be disabled with the <code>--no-cache</code> option.</p> <p>The generated output will roughly look like this:</p> <pre><code> -------------------------- --------------------------------------------------------------------------------------------------------------------------------\n  Reason                     Repository\n -------------------------- --------------------------------------------------------------------------------------------------------------------------------\n  DependsOnDisallowedLayer   examples\\MyNamespace\\Repository\\SomeRepository must not depend on examples\\MyNamespace\\Controllers\\SomeController\n                             You are depending on token that is a part of a layer that you are not allowed to depend on. (Controller)\n                             /Users/dbr/workspace/qossmic/deptrac/examples/ControllerServiceRepository1/SomeRepository.php:5\n -------------------------- --------------------------------------------------------------------------------------------------------------------------------\n\n\n -------------------- -----\n  Report\n -------------------- -----\n  Violations           1\n  Skipped violations   0\n  Uncovered            0\n  Allowed              4\n  Warnings             0\n  Errors               0\n -------------------- -----\n</code></pre> <p>This is a report generated by Deptrac. At the top you can see a list of violations, if there are any. A violation means, that a layer uses a layer that is prohibited by the configured ruleset. In this case, a class from the Repository layer uses a class from the Controller layer.</p> <p>The table on the bottom gives you an overview over:</p> <ul> <li>how many violations were found.</li> <li>how many violations were skipped, meaning your config contains exceptions.   which will not cause Deptrac to return with an error status code, e.g. in CI,   when these violations are found.</li> <li>how many classes were found in the directories, that were not assigned to a   layer.</li> <li>how many usages between layers were found that do not violate the ruleset.</li> <li>how many warnings where encountered, e.g. because a class is grouped in   multiple layers.</li> <li>how many errors were encountered, e.g. when you exclude a violation in your   config file but that violation is not encountered.</li> </ul> <p>If the output does not match your expectations please take a look at the debugging commands available in Deptrac.</p> <p>You can also change the output format itself by using one of the many provided Output Formatters.</p>"},{"location":"#contribute","title":"Contribute","text":"<p>Deptrac is in active development. We are looking for your suggestions and help to make it better.</p> <p>Feel free to open an issue if you encounter bugs, have suggestions or would like to add a new feature to Deptrac.</p> <p>Please feel free to improve this documentation, fix bugs, or work on a suggested feature by making a pull request on GitHub. Don't hesitate to ask for support, if you need help at any point.</p> <p>The Contribution Guide in the documentation contains some advice for making a pull request with code changes.</p>"},{"location":"#code-of-conduct","title":"Code of Conduct","text":"<p>If you are professional and polite then everything will be alright.</p> <p>Please don't be inconsiderate or mean, or anything in between.</p>"},{"location":"#further-documentation","title":"Further Documentation","text":"<ul> <li>Backwards Compatibility - General info on how we approach   backwards compatibility</li> <li>Upgrade Guide - List of backwards breaking changes that need to   be addressed when upgrading Deptrac to a new version and how to do it.</li> <li>Core Concepts - Explains layers, rules and violations in   more details.</li> <li>Configuration - Reference for all available settings in a   config file</li> <li>Collectors - Reference for which collectors are   available in Deptrac to define your layers.</li> <li>Formatters - Lists the different output formats   supported by Deptrac</li> <li>Debugging - Overview of the debug commands</li> <li>Code Of Conduct - Our community standards</li> <li>Contribute - Advice for contributing code changes,   e.g. how to run tests or how to build a phar file with your changes that you   can use to analyse your projects</li> <li>Security Guide - How to report security vulnerabilities</li> </ul>"},{"location":"CODE_OF_CONDUCT/","title":"Code of Conduct","text":"<p>If you are professional and polite, then everything will be alright. Please don't be inconsiderate and mean, or anything in between.</p> <p>We do not have a formal code of conduct. That being said, we do not tolerate harassment and will take action against any individual who is not acting professionally. This can range from reprimanding them privately to blocking them from interacting with the repository.</p> <p>QOSSMIC as owner is responsible for upholding the code of conduct and should be contacted if you have any issues. Please use the following email for this: wecare@qossmic.com</p>"},{"location":"CONTRIBUTING/","title":"Contributing to Deptrac","text":"<p>There are many ways to contribute to Deptrac, from helping others with their issues, improving the documentation to fixing bugs &amp; adding new features. The maintainers and contributors will help you best as they can, when you have questions or troubles. Feel free to reach out.</p> <p>When you want to add a new feature to Deptrac, please make sure to open an issue first to let others know who is working on it and prevent similar or conflicting pull requests. We are always happy to expand the possibilities of Deptrac to better fit the need of anyone who uses it. Before we merge changes, we have to decide whether we can maintain them without taking away resources needed elsewhere. Unfortunately, that means we have to reject some change requests. Opening an issue before you start working on any new feature will make sure that your merge request can be accepted.</p>"},{"location":"CONTRIBUTING/#requirements","title":"Requirements","text":"<ul> <li>PHP in version 8.1 or above</li> <li>Composer</li> <li><code>make</code></li> </ul>"},{"location":"CONTRIBUTING/#installing-tools","title":"Installing tools","text":"<p>You can install all tools needed for developing Deptrac using the Makefile by running the following command:</p> <pre><code>$ make composer-install\n</code></pre>"},{"location":"CONTRIBUTING/#pipeline","title":"Pipeline","text":"<p>Any merge request must pass our build pipeline which consists of the following:</p> <ul> <li>Unit Tests for all supported PHP-versions</li> <li>Check for coding guidelines</li> <li>Static code analysis with phpstan and psalm</li> <li>End 2 End-tests, ensuring <code>deptrac.phar</code> can be built</li> </ul> <p>You can use the provided Makefile to execute these steps locally. The <code>make</code> command is supported by most major operating systems, but you might need to install it first. The Makefile will use Composer to install the required tools like PHPUnit, Psalm or PHPStan. If you don't want to use Composer or the Makefile you will need to install them yourself.</p>"},{"location":"CONTRIBUTING/#tests","title":"Tests","text":"<p>You can run the unit tests locally using the provided Makefile</p> <pre><code>make tests\n</code></pre> <p>This will run phpunit to make sure the tests pass. We recommend running the tests once before you make any changes to ensure they work on your system. This way you can be sure that any failing test is not caused by a pre-existing problem.</p>"},{"location":"CONTRIBUTING/#code-style","title":"Code style","text":"<p>You can check if your code changes are in line with our coding guidelines using php-cs-fixer.</p> <pre><code>make php-cs-check\n</code></pre> <p>This will show you any code style violations that are also reported on Github. You can automatically fix them by running:</p> <pre><code>make php-cs-fix\n</code></pre>"},{"location":"CONTRIBUTING/#static-code-analysis","title":"Static code analysis","text":"<p>In order to perform static code analysis for your changes you can run:</p> <pre><code>make phpstan\nmake psalm\n</code></pre> <p>We also run a tool called infection for mutation testing:</p> <pre><code>make infection\n</code></pre>"},{"location":"CONTRIBUTING/#build-deptrac","title":"Build Deptrac","text":"<p>You can build the <code>deptrac.phar</code> both to ensure it works, as well as for using it to analyse your existing projects to see if your changes work as expected.</p> <pre><code>$ make build\n</code></pre> <p>This will create an executable file <code>deptrac.phar</code> in the current directory.</p>"},{"location":"CONTRIBUTING/#deptrac-engine-internals","title":"Deptrac Engine (Internals)","text":"<p>The internal Deptrac engine consists of several parts, some of those can be influenced by configuration or extensions (<code>Analyser</code>, <code>InputCollector</code>, <code>Dependency</code>, <code>Layer</code>), while others cannot (<code>Ast</code>). To give you a brief overview of how the pieces lock together, a diagram of <code>DependencyLayerAnalyser</code> run:</p> <pre><code>sequenceDiagram\n    participant A as Analyser\n    participant I as InputCollector\n    participant As as Ast\n    participant D as Dependency\n    participant L as Layer\n\n    A-&gt;&gt;I:  Collect files to analyse\n    I-&gt;&gt;A:  List of files to analyse\n\n    A-&gt;&gt;As: Create Ast for collected files\n    alt Cached\n        As-&gt;&gt;As:        Load cached \"AstMap\"\n    else Not cached\n        note over As:   Will collect all possible connections &lt;br/&gt; regradless of deptrac configuration\n        As-&gt;&gt;As:        Apply \"ReferenceExtractors\"\n    end\n    As-&gt;&gt;A: \"AstMap\" for all files\n\n    A-&gt;&gt;D:  Resolve all dependencies between Ast Nodes\n    D-&gt;&gt;D:  Apply all registered \"DependencyEmmiters\"\n    D-&gt;&gt;A:  \"DependencyList\" of all dependencies\n\n    loop for each dependency\n        A-&gt;&gt;L: Resolve layers for both sides of the dependency\n        L-&gt;&gt;A: One or more layers for each side\n        A-&gt;&gt;A: Build \"Result\" based on defined ruleset\n    end\n</code></pre>"},{"location":"CONTRIBUTING/#inputcollector","title":"InputCollector","text":"<p>Is responsible for collecting all the files to be analysed. By default, it uses the <code>deptrac.paths</code> section of the configuration to determine which files to collect and [<code>exclude_files</code>][depfile.md#exclude_files] to exclude filenames matching the specified patterns.</p>"},{"location":"CONTRIBUTING/#ast","title":"Ast","text":"<p>The Ast module is responsible for parsing all the provided files and building an Abstract Syntax Tree (AST) for those files. The <code>AstLoader</code> fetches everything, even if you have configured Deptrac to ignore some parts of the file, e.g. because the class is not in any layer or you configured <code>types</code> to ignore certain things like use-statements. Filtering the found dependencies happens in the next phase.</p> <p>The main part of the parsing is done in the <code>FileReferenceVisior</code>. This file is primarily concerned with keeping the appropriate scope (are you inside a class or a function) and also keeping track of currently applicable <code>@template</code> annotations. You can extend the functionality by adding extractors implementing the <code>ReferenceExtractorInterface</code> to build more connections between the nodes.</p> <p>The result is an <code>AstMap</code> containing all occurrences of found files, classes and functions. This is what gets saved into the <code>.deptrac.cache</code> file.</p>"},{"location":"CONTRIBUTING/#dependency","title":"Dependency","text":"<p>The Dependency module is concerned with taking the generated <code>AstMap</code> and converting it into a <code>DependencyList</code> of applicable dependencies between nodes based on the <code>deptrac.analyser.types</code> section of the configuration.</p> <p>Each type corresponds to an emitter implementing <code>DependencyEmitterInterface</code>.</p>"},{"location":"CONTRIBUTING/#layers","title":"Layers","text":"<p>As the name suggests, this module resolves what layers should each token be a part of. It leverages the collectors defined in the <code>deptrac.layers</code> section of the configuration.</p>"},{"location":"CONTRIBUTING/#analyser","title":"Analyser","text":"<p>The Analyser orchestrates between these modules. It calls the <code>InputCollector</code>, <code>Ast</code> and <code>Dependency</code> modules to generate a list of relevant dependencies matched to their layers, compares them against the <code>deptrac.ruleset</code> section of the configuration and finally generates a <code>Result</code>, which will be returned in the output.</p> <p>The <code>Result</code> is a collection of <code>Allowed</code>, <code>Error</code>, <code>Warning</code>, <code>Violation</code>, <code>Skipped</code> and <code>Uncovered</code> Rules. Those are then processed by the <code>OutputFormatters</code> to give you the desired output you can see when you call a command.</p>"},{"location":"SECURITY/","title":"Security Guideline","text":"<p>This document explains how Deptrac security issues are handled by the maintainers.</p>"},{"location":"SECURITY/#reporting-a-security-issue","title":"Reporting a security issue","text":"<p>If you think you have found a security issue in Deptrac, we ask you not to use the bug tracker and to not publish it publicly. Instead, all security issues must be sent to security@qossmic.com.</p>"},{"location":"SECURITY/#security-bug-bounties","title":"Security bug bounties","text":"<p>Deptrac is an Open-Source project where most of the work is done by volunteers. We appreciate that developers are trying to find security issues in Deptrac and report them responsibly, but we are currently unable to pay bug bounties.</p>"},{"location":"SECURITY/#process","title":"Process","text":"<p>In case of an incident being reported, we will...</p> <ol> <li>try to confirm the vulnerability.</li> <li>send an acknowledgement to the reporter, if the issue is confirmed</li> <li>start working on a patch</li> <li>prepare a security advisory to be published with the patch</li> <li>send the patch and advisory to the reporter for review</li> <li>apply the patch to all supported versions of Deptrac</li> <li>release a new version of Deptrac with the applied patch</li> <li>publish the advisory</li> </ol>"},{"location":"bc_policy/","title":"Backwards Compatibility Policy","text":"<p>Deptrac adheres to Semantic Versioning 2.0.0. That means, we will not introduce any breaking change in a minor or patch release starting with the first stable release 1.0.0. Within the 0.x.y major release, we may introduce breaking changes in minor releases.</p> <p>Given a version number MAJOR.MINOR.PATCH, increment the:</p> <ol> <li>MAJOR version when you make incompatible API changes</li> <li>MINOR version when you add functionality in a backwards compatible manner</li> <li>PATCH version when you make backwards compatible bug fixes</li> </ol> <p>First and foremost Deptrac is a command line utility, not a library. This governs what we consider a breaking change and might differ from your expectations from other packages. The following policy outlines what we consider breaking changes.</p> <p>We strongly suggest reading the Upgrade Guide for information on any planned breaking changes and how to deal with them. If you encounter a breaking change that is not documented, feel free to open an issue.</p>"},{"location":"bc_policy/#security","title":"Security","text":"<p>Security fixes may break backwards compatibility at any point. For more details on security related issues, please refer to the Security Guide.</p>"},{"location":"bc_policy/#commands","title":"Commands","text":"<p>Deptrac provides a series of commands such as <code>analyse</code>. The following things are considered breaking changes:</p> <ul> <li>Renaming or removing the command</li> <li>Renaming or removing options or arguments</li> <li>Changing the argument order</li> <li>Changing any of the expected values provided by Deptrac, e.g. formatter names</li> <li>Output (with some exceptions outlined below)</li> </ul> <p>Please notice, that the output is partly controlled by your system, e.g. line length. You might experience different output on different systems. However, you should be able to expect the same output on the same machine between version upgrades. We might make minor changes, such as fixing typos in a patch or minor release, if we assume the impact to users will be low. Generally speaking, formatters targeting CI systems, such as the Github-formatter, will be treated more strictly than for example the graphviz dot formatter, which is assumed to not be used directly in a CI pipeline.</p>"},{"location":"bc_policy/#configuration","title":"Configuration","text":"<p>Users of Deptrac should expect their initial configuration to work across newer minor and patch releases. As such, we will not make any breaking changes to configuration. Adding new (optional) configuration sections is allowed, but we will not alter existing fields and their expected types. You can expect the following breaking changes only to happen in a major release:</p> <ul> <li>Renaming or moving the default config file(name)</li> <li>Renaming or removing fields</li> <li>Making a previously optional field required</li> <li>Changing types of the config values</li> </ul>"},{"location":"bc_policy/#code","title":"Code","text":"<p>The following backwards compatibility promise extends only to code in the <code>Qossmic\\Deptrac\\Contract\\</code> namespace. Other code may change within a major release, unless it is marked explicitly as <code>@public</code>. Conversely, if anything in the Contract namespace is marked as <code>@internal</code> the BC promise does not apply.</p> <p>We try to follow Symfony's backwards compatibility promise as closely as possible. Please refer to their guide for a detailed explanation.</p> <p>In short, our interfaces and classes will not change unexpectedly within a major release.</p>"},{"location":"bc_policy/#features","title":"Features","text":"<p>Within a major version we will not unexpectedly remove or change features, e.g. remove a collectors arguments or its name or removing it entirely.</p> <p>Deptrac provides a series of extension points, e.g. events to hook into. You can expect these events to not be renamed or existing arguments, you might be using, to be altered within a major release.</p>"},{"location":"blog/","title":"Blog","text":""},{"location":"blog/#dynamic-deptrac-configuration-with-php-config-file","title":"Dynamic Deptrac configuration with PHP config file","text":"<p>May 11, 2023 - 5 min read</p>"},{"location":"collectors/","title":"Collectors","text":"<p>Collectors decide if a node (typically a class) is part of a layer. You can use multiple different collectors for a layer.</p>"},{"location":"collectors/#attribute-collector","title":"<code>attribute</code> Collector","text":"<p>The <code>attribute</code> collector finds all class-likes, functions or files using the provided attribute. You can provide the full attribute name or a substring that should be matched.</p> <pre><code>deptrac:\n  layers:\n    - name: Entities\n      collectors:\n        - type: attribute\n          value: Doctrine\\ORM\\Mapping\\Entity\n</code></pre>"},{"location":"collectors/#bool-collector","title":"<code>bool</code> Collector","text":"<p>The <code>bool</code> collector allows combining other collectors with or without negation.</p> <pre><code>deptrac:\n  layers:\n    - name: Asset\n      collectors:\n        - type: bool\n          must:\n            - type: classLike\n              value: .*Foo\\\\.*\n            - type: classLike\n              value: .*\\\\Asset.*\n          must_not:\n            - type: classLike\n              value: .*Assetic.*\n</code></pre> <p>Every class contains <code>Foo\\</code> AND <code>\\Asset</code> and NOT <code>Assetic</code>, will become a part of the Asset layer.</p>"},{"location":"collectors/#class-collector","title":"<code>class</code> Collector","text":"<p>The <code>class</code> collector allows collecting only classes by matching their fully qualified name to a simplified regular expression. Any match will be added to the assigned layer.</p> <pre><code>deptrac:\n  layers:\n    - name: Provider\n      collectors:\n        - type: class\n          value: .*Provider.*\n</code></pre> <p>Every class name that matches the regular expression becomes a part of the Provider layer. This collector has predefined delimiters and modifier: <code>/YOUR_EXPRESSION/i</code></p>"},{"location":"collectors/#classlike-collector","title":"<code>classLike</code> Collector","text":"<p>The <code>classLike</code> collector allows collecting classes and anything similar to classes like interfaces, traits or enums, by matching their fully qualified name to a simplified regular expression. Any match will be added to the assigned layer.</p> <pre><code>deptrac:\n  layers:\n    - name: Domain\n      collectors:\n        - type: classLike\n          value: .*Domain.*\n</code></pre> <p>Every classLike name that matches the regular expression becomes a part of the domain layer. This collector has predefined delimiters and modifier: <code>/YOUR_EXPRESSION/i</code></p>"},{"location":"collectors/#classnameregex-collector","title":"<code>classNameRegex</code> Collector","text":"<p>The <code>classNameRegex</code> collector allows collecting classes by matching their fully qualified name to a regular expression. Any matching class will be added to the assigned layer.</p> <pre><code>deptrac:\n  layers:\n    - name: Controller\n      collectors:\n        - type: classNameRegex\n          value: '#.*Controller.*#'\n</code></pre> <p>Every class name that matches the regular expression becomes a part of the controller layer.</p>"},{"location":"collectors/#tagvalueregex-collector","title":"<code>tagValueRegex</code> Collector","text":"<p>The <code>tagValueRegex</code> collector allows collecting classes and functions by matching the name and value of any tag in their phpdoc block, such as @internal or @deprecated.</p> <p>Any matching class will be added to the assigned layer.</p> <p><pre><code>deptrac:\n  layers:\n    - name: Deprecated\n      collectors:\n        - type: tagValueRegex\n          tag: '@deprecated'\n    - name: DeprecatedSinceV2\n      collectors:\n        - type: tagValueRegex\n          tag: '@deprecated'\n          value: '/^since v2/i'\n</code></pre> All classes tagged with \"@deprecated\" become part of the Deprecated layer. All classes that specify that they have been deprecated since v2 also become part of the DeprecatedSinceV2 layer.</p>"},{"location":"collectors/#composer-collector","title":"<code>composer</code> Collector","text":"<p>The <code>composer</code> collector allows you to define dependencies on composer <code>require</code> or <code>require-dev</code> packages that follow PSR-0 or PSR-4 autoloading convention. With this collector you can for example enforce:  - That your <code>require-dev</code> dependencies are only used in you non-production code (like DB migrations or SA tools)  - That your code does not use any transitive dependencies (dependencies on packages installed only because your <code>composer.json</code> required packages depend on them themselves)  - That some packages are only used in particular layers</p> <pre><code>deptrac:\n  layers:\n    - name: Symfony\n      collectors:\n        - type: composer\n          composerPath: composer.json\n          composerLockPath: composer.lock\n          packages:\n            - symfony/config\n            - symfony/console\n</code></pre>"},{"location":"collectors/#directory-collector","title":"<code>directory</code> Collector","text":"<p>The <code>directory</code> collector allows collecting classes by matching their file path they are declared in to a simplified regular expression. Any matching class will be added to the assigned layer.</p> <pre><code>deptrac:\n  layers:\n    - name: Controller\n      collectors:\n        - type: directory\n          value: src/Controller/.*\n</code></pre> <p>Every file path that matches the regular expression <code>src/Controller/.*</code> becomes a part of the controller layer. This collector has predefined delimiters and modifier: <code>#YOUR_EXPRESSION#i</code></p>"},{"location":"collectors/#extends-collector","title":"<code>extends</code> Collector","text":"<p>The <code>extends</code> collector allows collecting classes extending a specified class by matching recursively for a fully qualified class or interface name.</p> <pre><code>deptrac:\n  layers:\n    - name: Foo\n      collectors:\n        - type: extends\n          value: 'App\\SomeClass'\n</code></pre>"},{"location":"collectors/#functionname-collector","title":"<code>functionName</code> Collector","text":"<p>The <code>functionName</code> collector allows collecting functions by matching their fully qualified name to a simplified regular expression. Any matching function will be added to the assigned layer.</p> <pre><code>deptrac:\n  layers:\n    - name: Foo\n      collectors:\n        - type: functionName\n          value: .*array_.*\n</code></pre>"},{"location":"collectors/#glob-collector","title":"<code>glob</code> Collector","text":"<p>The <code>glob</code> collector finds all files matching the provided glob pattern.</p> <pre><code>deptrac:\n  layers:\n    - name: Repositories\n      collectors:\n        - type: glob\n          value: src/Modules/**/Repository\n</code></pre>"},{"location":"collectors/#implements-collector","title":"<code>implements</code> Collector","text":"<p>The <code>implements</code> collector allows collecting classes implementing a specified interface by matching recursively for a fully qualified interface name.</p> <pre><code>deptrac:\n  layers:\n    - name: Foo\n      collectors:\n        - type: implements\n          value: 'App\\SomeInterface'\n</code></pre>"},{"location":"collectors/#interface-collector","title":"<code>interface</code> Collector","text":"<p>The <code>interface</code> collector allows collecting only interfaces by matching their fully qualified name to a simplified regular expression. Any matching interface will be added to the assigned layer.</p> <pre><code>deptrac:\n  layers:\n    - name: Contracts\n      collectors:\n        - type: interface\n          value: .*Contracts.*\n</code></pre> <p>Every interface name that matches the regular expression becomes a part of the Interfaces layer. This collector has predefined delimiters and modifier: <code>/YOUR_EXPRESSION/i</code></p>"},{"location":"collectors/#inherits-collector","title":"<code>inherits</code> Collector","text":"<p>The <code>inherits</code> collector allows collecting classes inheriting from a specified class, whether by implementing an interface, extending another class or by using a trait, by matching recursively for a fully qualified class name.</p> <pre><code>deptrac:\n  layers:\n    - name: Foo\n      collectors:\n        - type: inherits\n          value: 'App\\SomeInterface'\n</code></pre>"},{"location":"collectors/#layer-collector","title":"<code>layer</code> Collector","text":"<p>This collector collects all the tokens collected by another layer. It is not very useful by itself (unless you want to have tokens in multiple layers), but it is very useful to exclude classes in combination with the <code>bool</code> Collector:</p> <pre><code>deptrac:\n  layers:\n    - name: SubDomain\n      collectors:\n        - type: directory\n          value: src/Domain/Subdomain/.*\n    - name: Domain\n      collectors:\n        - type: bool\n          must:\n            - type: directory\n              value: src/Domain/.*\n          must_not:\n            - type: layer\n              value: SubDomain\n</code></pre>"},{"location":"collectors/#method-collector","title":"<code>method</code> Collector","text":"<p>The <code>method</code> collector allows collecting classes by matching their methods name to a regular expression. Any matching class will be added to the assigned layer.</p> <pre><code>deptrac:\n  layers:\n    - name: Foo services\n      collectors:\n        - type: method\n          value: .*foo\n</code></pre> <p>Every class having a method that matches the regular expression <code>.*foo</code>, e.g. <code>getFoo()</code> or <code>setFoo()</code> becomes a part of the Foo services layer.</p>"},{"location":"collectors/#superglobal-collector","title":"<code>superglobal</code> Collector","text":"<p>The <code>superglobal</code> collector allows collecting superglobal PHP variables matching the specified superglobal name.</p> <pre><code>deptrac:\n  layers:\n    - name: Foo\n      collectors:\n        - type: superglobal\n          value:\n            - _POST\n            - _GET\n</code></pre>"},{"location":"collectors/#trait-collector","title":"<code>trait</code> Collector","text":"<p>The <code>trait</code> collector allows collecting only traits by matching their fully qualified name to a simplified regular expression. Any matching trait will be added to the assigned layer.</p> <pre><code>deptrac:\n  layers:\n    - name: Traits\n      collectors:\n        - type: trait\n          value: .*Traits.*\n</code></pre> <p>Every trait name that matches the regular expression becomes a part of the traits layer. This collector has predefined delimiters and modifier: <code>/YOUR_EXPRESSION/i</code></p>"},{"location":"collectors/#uses-collector","title":"<code>uses</code> Collector","text":"<p>The <code>uses</code> collector allows collecting classes using a specified trait by matching recursively for a fully qualified trait name.</p> <pre><code>deptrac:\n  layers:\n    - name: Foo\n      collectors:\n        - type: uses\n          value: 'App\\SomeTrait'\n</code></pre>"},{"location":"collectors/#php-internal-collector","title":"<code>PHP Internal</code> Collector","text":"<p>The <code>PHP Internal</code> collector collects PHP defined classes and functions including those loaded with PHP extensions.</p> <pre><code>deptrac:\n  layers:\n    - name: Foo\n      collectors:\n        - type: php_internal\n          value: ^reset$\n</code></pre>"},{"location":"collectors/#custom-collectors","title":"Custom Collectors","text":"<p>You can create custom collectors in your project by implementing the <code>Qossmic\\Deptrac\\Contract\\Layer\\CollectorInterface</code>. As soon as an unknown collector is referenced in the config file Deptrac will try to load the class in your project. With this you can create collectors specific for your use case.</p> <p>If you would like to make your collector available to others, feel free to contribute it by making a pull request.</p>"},{"location":"collectors/#extra-collector-configuration","title":"Extra collector configuration","text":"<p>Any collector can also specify parameter <code>private:true</code> like this:</p> <pre><code>deptrac:\n  layers:\n    - name: Foo\n      collectors:\n        - type: uses\n          value: 'App\\SomeTrait'\n          private: true\n</code></pre> <p>This means that tokens collected by this specific collector can be referenced only by other tokens in the same layer. References from other layers will be considered violations, even if they would normally be allowed by configured ruleset.</p> <p>This can be useful at least in 2 cases:  - External library that should be used only by one particular layer - In this case, you might via vendor include a library that should be used only by this particular layer and nobody else.  - Layer that has a public API and private implementation - You might want to provide only a few classes to be available to use by other layers (public API) that call the internal implementation of the layer that on the other hand should not be available to anybody else other than the public API of the layer.</p>"},{"location":"concepts/","title":"Core concepts","text":"<p>At the heart of Deptrac are three main concepts:</p> <ul> <li>Layers are groups of classes that you define</li> <li>Rulesets Describe whether which layers a   layer can communicate with, i.e. which classes are allowed in that layer</li> <li>Violations show when a layer uses classes from another   layer that is forbidden by the currently configured rulesets.</li> </ul>"},{"location":"concepts/#layers","title":"Layers","text":"<p>Deptrac allows you to group different tokens(classes, function, file usage outside those) into layers. Technically layers are nothing more than a collection of those tokens.</p> <p>Each layer has a unique name and a list of one or more collectors, which will look for tokens should be assigned to this layer (and yes, tokens can be assigned to more than one layer).</p> <p>If you want to ensure your application follows the MVC architecture pattern then you can create a config file that makes sure a View does not directly interact with a Controller or that Models are independent of both Views and Controllers.</p> <p>Another example for layers are bundles in Symfony applications. Each bundle should be independent by design. You can create layers for each bundle you have in your application and then ensure that they do not use tokens from any of the other bundles. This is particularly helpful when you have an application with many bundles as it will tell you which ones to consolidate and which ones can be extracted and reused.</p> <p>Deptrac allows you to visualize and enforce a ruleset based on such layer information.</p> <p>So you could define that every class that ends with <code>Controller</code> will be assigned to the Controller layer, and every class that has <code>\\Model\\</code> in its namespace will be added to the Model layer.</p> <p>By default, all dependencies between layers are forbidden!</p>"},{"location":"concepts/#collecting-layers","title":"Collecting Layers","text":"<p>If your application has controllers and models, Deptrac allows you to group them into layers.</p> <pre><code>deptrac:\n  paths:\n    - ./examples/ModelController\n  exclude_files: ~\n  layers:\n    -\n      name: Models\n      collectors:\n        -\n          type: classLike\n          value: .*MyNamespace\\\\Models\\\\.*\n    -\n      name: Controller\n      collectors:\n        -\n          type: classLike\n          value: .*MyNamespace\\\\.*Controller.*\n  ruleset: [ ]\n</code></pre> <p>At first, lets take a closer look at the first layer (named Models).</p> <p>Here we decided that our software has some kind of layer called Models. You assign tokens to this layer with the help of Collectors.</p> <p>Collectors are responsible for taking a closer look at your code and decide if a token is part of a layer. By using the <code>classLike</code> collector you can define a regular expression for a class name. Every (fully qualified) class name that matches this regular expression becomes part of the assigned layer. In this example we define that every class that contains <code>MyNamespace\\Models\\</code> will be a part of the Model layer.</p> <p>Every class that matches <code>.*MyNamespace\\\\.*Controller.*</code> will become a part of the Controller layer.</p> <p>As we defined our layers, we can generate a dependency graph for the example configuration: (Make sure that Graphviz (dot) is installed on your system)</p> <pre><code>$ php deptrac.phar analyse --config-file=examples/ModelController1.depfile.yaml\n</code></pre> <p>After Deptrac has finished, an image should be opened:</p> <p></p> <p>On your command line Deptrac will produce this output:</p> <pre><code>Start to create an AstMap for 2 Files.\n..\nAstMap created.\nstart emitting dependencies \"InheritanceDependencyEmitter\"\nstart emitting dependencies \"BasicDependencyEmitter\"\nend emitting dependencies\nstart flatten dependencies\nend flatten dependencies\ncollecting violations.\nformatting dependencies.\n\nFound 0 Violations\n</code></pre> <p>The output shows, that Deptrac is parsing 2 files and found 0 violations. By default, every dependency between layers is a violation. In our case there are (for now) no dependencies between our classes (layers). It's fine that Deptrac will show us two independent layers without any relationship.</p>"},{"location":"concepts/#ruleset-allowing-dependencies","title":"Ruleset (Allowing Dependencies)","text":"<p>Allowed dependencies between layers are configured in a ruleset.</p> <p>By default, Deptrac will raise a violation for every dependency between layers. In real software you want to allow dependencies between different kinds of layers.</p> <p>As a lot of architectures define some kind of controllers, services and repositories, a natural approach for this would be to define these rules:</p> <ul> <li>Controllers may access services, but not repositories.</li> <li>Services may access repositories, but not controllers.</li> <li>Repositories neither may access services nor controllers.</li> </ul> <p>We can define this using the following configuration:</p> <pre><code># deptrac.yaml\ndeptrac:\n  paths:\n    - ./examples/ControllerServiceRepository1/\n  exclude_files: ~\n  layers:\n    -\n      name: Controller\n      collectors:\n        -\n          type: classLike\n          value: .*MyNamespace\\\\.*Controller.*\n    -\n      name: Repository\n      collectors:\n        -\n          type: classLike\n          value: .*MyNamespace\\\\.*Repository.*\n    -\n      name: Service\n      collectors:\n        -\n          type: classLike\n          value: .*MyNamespace\\\\.*Service.*\n  ruleset:\n    Controller:\n      - Service\n    Service:\n      - Repository\n    Repository: ~\n</code></pre> <p>Take a closer look at the ruleset. We allow the Controller layer to access Service and Service can access Repository, but Repository may not access any of the two other layers.</p> <p>After running Deptrac we will get this result:</p> <p></p> <pre><code>Start to create an AstMap for 3 Files.\n...\nAstMap created.\nstart emitting dependencies \"InheritanceDependencyEmitter\"\nstart emitting dependencies \"BasicDependencyEmitter\"\nend emitting dependencies\nstart flatten dependencies\nend flatten dependencies\ncollecting violations.\nformatting dependencies.\nexamples\\MyNamespace\\Repository\\SomeRepository::5 must not depend on examples\\MyNamespace\\Controllers\\SomeController (Repository on Controller)\n</code></pre> <p>Deptrac now finds a violation. If we take a closer look at the \"SomeRepository\" on line 5, we will see an unused use statement for a controller:</p> <pre><code>namespace examples\\MyNamespace\\Repository;\n\nuse examples\\MyNamespace\\Controllers\\SomeController;\n\nclass SomeRepository { }\n</code></pre> <p>If we remove the <code>use</code> statement and rerun Deptrac, the violation will disappear.</p>"},{"location":"concepts/#different-layers-and-different-views","title":"Different Layers and Different Views","text":"<p>In the example above we defined 3 different layers (controller, repository and service). Deptrac gives architects the power to define what kind of layers exist.</p> <p>Typical use cases are:</p> <ul> <li>caring about layers in different architectures (tier, hexagonal, ddd, ...)</li> <li>caring about dependencies between different kinds of services (infrastructure   services / domain services / entities / DTOs / ...)</li> <li>caring about coupling to third party code like composer vendors, frameworks,   ...</li> <li>enforcing naming conventions</li> <li>...</li> </ul> <p>Typically software has more than just one view. It is possible to use multiple config files, to take care about different architectural views.</p>"},{"location":"concepts/#uncovered-dependencies","title":"Uncovered dependencies","text":"<p>Deptrac collects uncovered dependencies which can be reported with the Console Formatter. By default, internal php classes will not be considered. This can be changed by adding <code>ignore_uncovered_internal_classes: false</code> to your configuration.</p> <p>You can use the <code>--fail-on-uncovered</code> option to let Deptrac fail when any uncovered dependencies are encountered.</p> <p>You can use the <code>--report-uncovered</code> option to let you know about any uncovered dependencies in the report that is generated by Deptrac.</p>"},{"location":"concepts/#internal-and-deptrac-internal-annotation","title":"@internal and @deptrac-internal annotation","text":"<p>You can mark your classes with <code>@internal</code> or <code>@deptrac-internal</code> annotation. If you do so, the marked class cannot be referenced by any class outside its layer. This will supersede any ruleset configuration you might have defined. This way, you don't have to define 2 separate layers to distinguish between layers external API and its private implementation.</p>"},{"location":"concepts/#violations","title":"Violations","text":"<p>If we have 2 layers (Models, Controller) and one layer is using the other, Deptrac will raise a violation by default:</p> <pre><code>// see the example in examples/ModelController2\nnamespace examples\\MyNamespace\\Controllers;\n\nuse examples\\MyNamespace\\Models\\SomeModel;\n\nclass SomeController\n{\n    public function foo(SomeModel $m) {\n        return $m;\n    }\n}\n</code></pre> <p>After running Deptrac for this example</p> <pre><code>$ php deptrac.phar analyse --config-file=examples/ModelController2.depfile.yaml\n</code></pre> <p>we will get this output:</p> <pre><code>Start to create an AstMap for 2 Files.\n..\nAstMap created.\nstart emitting dependencies \"InheritanceDependencyEmitter\"\nstart emitting dependencies \"BasicDependencyEmitter\"\nend emitting dependencies\nstart flatten dependencies\nend flatten dependencies\ncollecting violations.\nformatting dependencies.\nexamples\\MyNamespace\\Controllers\\SomeController::5 must not depend on examples\\MyNamespace\\Models\\SomeModel (Controller on Models)\nexamples\\MyNamespace\\Controllers\\SomeController::9 must not depend on examples\\MyNamespace\\Models\\SomeModel (Controller on Models)\n\nFound 2 Violations\n</code></pre> <p></p> <p>Deptrac has found two violations because the relation from the controller to model layers is not allowed. The console output shows exactly the lines Deptrac found.</p>"},{"location":"concepts/#skip-violations","title":"Skip violations","text":"<p>Deptrac integration into existing CI/CD pipeline might be difficult because of existing dependency violations in the code. In this case, you can skip existing violations to gradually improve your code and avoid possibility introduce any new violations.</p> <p>Violations can be skipped by provided list of dependencies in skip_violations configuration section:</p> <pre><code>deptrac:\n  skip_violations:\n    Library\\LibClass:\n      - Core\\CoreClass\n</code></pre> <p>skip_violations section contains an associative array where a key (<code>Library\\LibClass</code>) is the name of dependent token and values (<code>Core\\CoreClass</code>) are dependency tokens.</p> <p>Matched violations will be marked as skipped:</p> <pre><code>$ php deptrac.phar analyse --config-file=examples/SkipViolations.yaml --report-skipped\n1/1 [\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593] 100%\n\n[SKIPPED] Library\\LibClass must not depend on Core\\CoreClass (Library on Core)\n/path/examples/SkipViolations/SkipViolations.php::11\n\n[ERROR] Skipped violation \"Core\\Unmatched\" for \"Library\\LibClass\" was not matched.\n\nReport:\nViolations: 0\nSkipped violations: 1\nUncovered: 0\nAllowed: 1\n</code></pre>"},{"location":"configuration/","title":"Configuration","text":"<p>The configuration file describes your layers, ruleset and adjusts output formatting.</p> <p>We suggest you also check out Deptrac's configuration for checking its own architecture as it uses most available options.</p>"},{"location":"configuration/#deptrac","title":"Deptrac","text":"<p>The following table shows the available config keys for Deptrac.</p> Property Path Input description Example usage analyser.internal_tag  Specifies a custom doc block tag which deptrac should use to identify layer-internal class-like structures. The tag <code>@deptrac-internal</code> will always be used for this purpose. This option allows an additional tag to be specified, such as <code>@layer-internal</code> or plain <code>@internal</code>.  <pre><code>deptrac:\n  analyser:\n    internal_tag: \"@layer-internal\"\n</code></pre> analyser.types   A list with at least one of the following supported dependency types: <ul> <li>class default \u2014 analyses class definitions for everything apart from superglobal usage. </li> <li>class_superglobal \u2014 analyses class definitions for superglobal usage. </li> <li>use default \u2014 analyses file definitions for use statements. </li> <li>file \u2014 analyses file for everything apart from use statements and function/class definitions. </li> <li>function \u2014 analyses function definitions for everything apart from superglobal usage. </li> <li>function_superglobal \u2014 analyses function definitions for superglobal usage. </li> <li>function_call \u2014 analyses calls to custom(user-defined) functions   <pre><code>deptrac:\n  analyser:\n    types:\n      - \"use\"\n      - \"file\"\n      - \"class_superglobal\"\n      - \"function_superglobal\"\n      - \"function_call\"\n</code></pre> paths   List of paths where Deptrac should look for dependencies to be analysed. Usually, this is where your code is stored, e.g. <code>src/</code>, or <code>lib/</code> or something similar.   <pre><code>deptrac:\n  paths:\n    - src/\n</code></pre> exclude_files   A list of regular expression-patterns to determine which files or directories to exclude, e.g. test files or config   <pre><code>deptrac:\n  exclude_files:\n    - '#.*Test\\.php$#'\n</code></pre> formatters.graphviz.groups   Key is the name of the group and values are the layers belonging to that group   <pre><code>deptrac:\n  formatters:\n    graphviz:\n      groups:\n        Entrypoints:\n          - Controllers\n          - Commands\n        Persistence:\n          - Repositories\n          - Entities\n</code></pre> formatters.graphviz.hidden_layers   List of layers to be excluded from the Graphviz output   <pre><code>deptrac:\n  formatters:\n    graphviz:\n      hidden_layers:\n        - Controllers\n</code></pre> formatters.codeclimate.severity   Assigns a severity to each section reported by Deptrac. The following severity types are supported by codeclimate: <ul> <li>info</li> <li>minor</li> <li>major</li> <li>critical</li> <li>blocker</li> </ul> <pre><code>deptrac:\n  formatters:\n    codeclimate:\n      severity:\n        failure: blocker\n        skipped: major\n        uncovered: major\n</code></pre> deptrac.ignore_uncovered_internal_classes   Whether PHP-internal classes like <code>DateTimeImmutable</code> should count towards uncovered classes, when they are not part of any layer.   <pre><code>deptrac:\n  ignore_uncovered_internal_classes: false # default: true\n</code></pre> deptrac.layers   Defines your architectural layers by collecting dependencies using collectors   <pre><code>deptrac:\n  layers:\n    -\n      name: Controller\n      collectors:\n        -\n          type: classLike\n          value: .*Controller.*\n</code></pre> deptrac.ruleset   Assign communication rules by specifying which layers a layer can communicate with (if any). If you prepend a layer with <code>+</code> then not only this layer is allowed, but also all layers it allows.   <pre><code>deptrac:\n  ruleset:\n    Controllers: [Services]\n    Services:\n      - Repositories\n    Repositories: ~\n</code></pre> deptrac.skip_violations   Define a dictionary of dependencies and their known violations. This violations will be ignored in your pipeline and not trigger a failing return code.   <pre><code>deptrac:\n  skip_violations:\n    Library\\LibClass:\n      - Core\\CoreClass\n</code></pre>"},{"location":"configuration/#imports","title":"Imports","text":"<p>If your config file becomes too large, you can split it up into multiple files that can then be imported in the main file using the <code>imports</code> section. This is also useful to separate your baseline from the rest of the configuration, so it can be regenerated by the <code>baseline</code> formatter.</p> <p>Example:</p> <pre><code>imports:\n  - deptrac.baseline.yaml\n</code></pre>"},{"location":"configuration/#services","title":"Services","text":"<p>Please see Symfony docs. This allows you to register new services, e.g. custom formatters or collectors.</p> <pre><code>services:\n  - class: Internal\\Qossmic\\Deptrac\\IgnoreDependenciesOnContract\n    tags:\n      - { name: kernel.event_listener, event: Qossmic\\Deptrac\\Contract\\Analyser\\ProcessEvent }\n</code></pre>"},{"location":"configuration/#parameters","title":"Parameters","text":"<p>Deptrac provides parameters that can be user in your configuration.</p> <ul> <li><code>%currentWorkingDirectory%</code> The path Deptrac runs in</li> <li><code>%projectDirectory%</code> The path where the configuration is stored.</li> <li><code>%cache_file%</code> contains the filename and path for the cache file.   Note: This parameter is overwritten by <code>--cache-file=</code> if it is set.</li> </ul> <p>You can specify your own parameters and reuse them in your configuration:</p> <p>Example:</p> <pre><code>parameters:\n  Project: MyProject\n\ndeptrac:\n  layers:\n    -\n      name: Foo\n      collectors:\n        -\n          type: implements\n          value: '%Project%\\SomeInterface'\n</code></pre>"},{"location":"debugging/","title":"Debugging","text":"<p>Deptrac provides a series of debug commands that help you identify issues in your config files. All commands output one issue per line and can therefore be easily combined with other tools like <code>wc</code> or <code>grep</code>.</p>"},{"location":"debugging/#debuglayer","title":"<code>debug:layer</code>","text":"<p>With the <code>debug:layer</code>-command you can list all tokens which are matched in a specific layer. This command only shows tokens that would be emitted by your analyser configuration.</p> <pre><code>$ php deptrac.phar debug:layer --config-file=deptrac.config.php Time\n\n ---------------------------------------------------- ------------\n  Time                                                 Token Type\n ---------------------------------------------------- ------------\n  /src/Supportive/Time/Period.php                      file\n  /src/Supportive/Time/StartedPeriod.php               file\n  /src/Supportive/Time/Stopwatch.php                   file\n  /src/Supportive/Time/StopwatchException.php          file\n  Qossmic\\Deptrac\\Supportive\\Time\\Period               class-like\n  Qossmic\\Deptrac\\Supportive\\Time\\StartedPeriod        class-like\n  Qossmic\\Deptrac\\Supportive\\Time\\Stopwatch            class-like\n  Qossmic\\Deptrac\\Supportive\\Time\\StopwatchException   class-like\n ---------------------------------------------------- ------------\n</code></pre>"},{"location":"debugging/#debugtoken","title":"<code>debug:token</code>","text":"<p>The <code>debug:token</code> (previously <code>debug:class-like</code>)-command will let you know which layers a specified token belongs to. Since you can specify the token type, this commands ignores your analyser configuration for emitted token types.</p> <pre><code>$ php deptrac.phar debug:token --config-file=examples/DirectoryLayer.depfile.yaml 'examples\\Layer1\\AnotherClassLikeAController' class-like\n\nController\nLayer1\n</code></pre>"},{"location":"debugging/#debugunassigned","title":"<code>debug:unassigned</code>","text":"<p>With the <code>debug:unassigned</code>-command you list all tokens in your path that are not assigned to any layer. This is useful to test that your collector configuration for layers is correct.  This command only shows tokens that would be emitted by your analyser configuration.</p> <pre><code>$ php deptrac.phar debug:unassigned --config-file=examples/DirectoryLayer.depfile.yaml\n\nexamples\\Layer1\\AnotherClassLikeAController\nexamples\\Layer1\\SomeClass\nexamples\\Layer1\\SomeClass2\n</code></pre> <p>This command exist with the return code 2 when it ran successfully, but there were some tokens in the output. You can use this information in your CI pipelines.</p>"},{"location":"debugging/#debugdependencies","title":"<code>debug:dependencies</code>","text":"<p>With the <code>debug:dependencies</code>-command you can see all dependencies of your layer. You can optionally specify a target layer to get only dependencies from one layer to the other:</p> <pre><code>$ php deptrac.phar debug:dependencies debug:dependencies Ast InputCollector\n\n  Qossmic\\Deptrac\\Core\\Ast\\AstMapExtractor depends on Qossmic\\Deptrac\\Core\\InputCollector\\InputCollectorInterface (InputCollector)\n  .../deptrac/src/Core/Ast/AstMapExtractor.php:15\n  Qossmic\\Deptrac\\Core\\Ast\\AstMapExtractor depends on Qossmic\\Deptrac\\Core\\InputCollector\\InputException (InputCollector)\n  .../deptrac/src/Core/Ast/AstMapExtractor.php:28\n  Qossmic\\Deptrac\\Core\\Ast\\AstException depends on Qossmic\\Deptrac\\Core\\InputCollector\\InputException (InputCollector)\n  .../deptrac/src/Core/Ast/AstException.php:13\n</code></pre>"},{"location":"debugging/#debugunused","title":"<code>debug:unused</code>","text":"<p>With the <code>debug:unused</code>-command you list all the rulesets that are not being used (i.e. there are no dependencies being allowed by this ruleset).</p> <p>You can optionally specify a limit (<code>--limit=&lt;int&gt;</code>) of how many times can be the ruleset used to be considered unused. This is useful if you want to find dependencies that are barely used and may be a prime candidate to get rid of.</p> <pre><code>$ php deptrac.phar debug:unused --limit=10\n\n  Analyser layer is dependent Layer layer 5 times\n  Ast layer is dependent File layer 9 times\n  Ast layer is dependent InputCollector layer 3 times\n  Console layer is dependent OutputFormatter layer 4 times\n  Console layer is dependent DependencyInjection layer 2 times\n  Console layer is dependent File layer 5 times\n  InputCollector layer is dependent File layer 3 times\n  OutputFormatter layer is dependent DependencyInjection layer 1 times\n</code></pre>"},{"location":"debugging/#changed-files","title":"<code>changed-files</code>","text":"<p>[!CAUTION] This command in experimental and is not covered by the BC policy.</p> <p>This command list the layers corresponding to the passed files. Optionally it can also list all the layers that depend on those layers.</p> <pre><code>$ php deptrac.phar changed-files --with-dependencies src/Supportive/File/FileReader.php\n\n  File\n  Console;Ast;InputCollector;Analyser;Dependency;Layer\n</code></pre> <p>For a discussion as to why that information might be useful, refer to the 90DaysOfDevOps Presentation.</p>"},{"location":"extending_deptrac/","title":"Extending Deptrac","text":"<p>Deptrac defines its extension points by providing a set of contract classes that you can depend on for your implementation. The classes can be found in the <code>src/Contract</code> directory and are covered by the backwards compatibility policy promise, meaning they will stay stable within major releases.</p> <p>There are several ways you can extend Deptrac:</p> <ul> <li>Output formatters - To change how the output of   dependency analysis is formatted. This might be useful to integrate Deptrac   into your CI/CD pipeline.</li> <li>Analyser Events - Decide whether a dependency is   Uncovered, Allowed, Violation or SkippedViolation.</li> <li>Layer collectors - Add custom collectors for organizing your code into layers</li> </ul> <p>Note In examples where FQCN is not specified, the base namespace <code>Qossmic\\Deptrac\\Contract\\</code> is omitted for readability.</p>"},{"location":"extending_deptrac/#output-formatters","title":"Output Formatters","text":"<p>Creating an output formatter requires creating a new class implementing the <code>OutputFormatter\\OutputFormatterInterface</code> and register it in your <code>deptrac.yaml</code> file like this:</p> <pre><code>services:\n  - class: App\\DeptracExtension\\MyCustomOutputFormatter\n    autowire: true\n    tags:\n      - output_formatter\n</code></pre> <p>And you are done. You can call your formatter by using the <code>-f</code> or <code>--formatter</code> CLI flag with the name you defined in the <code>getName()</code>-method of your formatter.</p>"},{"location":"extending_deptrac/#analyser-events","title":"Analyser Events","text":"<p>The deptrac analyser creates a <code>Analyser\\ProcessEvent</code> for each dependency it finds. You can listen for this event and decide how to handle it depending on the details of the dependency.</p> <p>This might be useful when you want to ignore a specific group of violations in testing-related code for example. First you create a class to process this event:</p> <pre><code>namespace App\\DeptracExtension;\n\nuse Qossmic\\Deptrac\\Contract\\Analyser\\ProcessEvent;\n\nclass IgnoreDependenciesOnShouldNotHappenException implements \\Symfony\\Component\\EventDispatcher\\EventSubscriberInterface\n{\n    public function onProcessEvent(ProcessEvent $event): void\n    {\n        if (\"Qossmic\\Deptrac\\Contract\\ExceptionInterface\" === $event-&gt;dependentReference-&gt;getToken()-&gt;toString()) {\n            $event-&gt;stopPropagation();\n        }\n    }\n\n    public static function getSubscribedEvents(): array\n    {\n        return [\n            ProcessEvent::class =&gt; 'onProcessEvent',\n        ];\n    }\n}\n</code></pre> <p>And then you register this class in your <code>deptrac.yaml</code> file:</p> <pre><code>services:\n  - class: IgnoreDependenciesOnShouldNotHappenException\n    tags:\n      - { name: kernel.event_subscriber }\n</code></pre> <p>You can also en masse change the whole result set by instead listening to the <code>Analyser\\PostProcessEvent</code>. This allows you to add Rules (Uncovered, Allowed, Violation, SkippedViolation), Warnings and Errors to the analysis result. Do so by calling the <code>replaceResult()</code> method.</p>"},{"location":"extending_deptrac/#layer-collectors","title":"Layer collectors","text":"<p>Deptrac already comes with a comprehensive list of collectors. If you need something more specific, you can write your own collector implementing <code>Layer\\CollectorInterface</code> and register it in your <code>deptrac.yaml</code> file:</p> <pre><code>services:\n  - class: App\\DeptracExtension\\MyCustomLayerCollector\n    autowire: true\n    tags:\n      - { name: 'collector', type: '&lt;name to use in the CLI flag to invoke the collector&gt;' }\n</code></pre>"},{"location":"formatters/","title":"Formatters","text":"<p>Deptrac has support for different output formatters with various options.</p> <p>You can get a list of available formatters by running</p> <pre><code>$ php deptrac.php analyse --help\n</code></pre>"},{"location":"formatters/#baseline-formatter","title":"Baseline Formatter","text":"<p>The Baseline formatter is a console formatter, which generates the <code>skip_violations</code> section to the given File. With this formatter it's possible to start on a project with some violations without a failing CI Build.</p> <p>Note: It's not the best solution to ignore all the errors because maybe your current Architecture doesn't allow a change without a new violation.</p> <p>It can be activated with <code>--formatter=baseline</code>.</p> <p>Supported options:</p> <pre><code>--output[=BASELINE-DUMP] path to a dumped baseline file [default: \"./deptrac.baseline.yaml\"]\n</code></pre> <p>Don't forget to include the baseline into your existing <code>deptrac.yaml</code></p> <pre><code># deptrac.yaml\nimports:\n  - deptrac.baseline.yaml\n</code></pre>"},{"location":"formatters/#console-formatter","title":"Console Formatter","text":"<p>This formatter dumps basic information to STDOUT,</p> <pre><code>examples\\MyNamespace\\Repository\\SomeRepository::5 must not depend on examples\\MyNamespace\\Controllers\\SomeController (Repository on Controller)\n</code></pre>"},{"location":"formatters/#githubactions-formatter","title":"GitHubActions Formatter","text":"<p>The GithubActions formatter is a console formatter, which dumps basic information in github-actions format to STDOUT. This formatter is enabled by default while running in a GitHub actions environment. It can be activated manually with <code>--formatter=github-actions</code>.</p> <pre><code>::error file=/home/testuser/originalA.php,line=12::ACME\\OriginalA must not depend on ACME\\OriginalB (LayerA on LayerB)\n</code></pre>"},{"location":"formatters/#graphviz-formatters","title":"Graphviz Formatters","text":"<p>There is a whole family of Graphviz formatters for you to choose from depending on what type of output you are expecting. They can be activated with:</p> <pre><code>--formatter=graphviz-display    Automatically tries to open the image\n--formatter=graphviz-dot        Saves the output to a .dot file\n--formatter=graphviz-html       Saves the output to a .html file\n--formatter=graphviz-image      Saves the output to a supported image file format such as png, svg or jpg\n</code></pre> <p>Supported options:</p> <pre><code>--output= path to a dumped file\n</code></pre>"},{"location":"formatters/#hide-layers-in-output","title":"Hide layers in output","text":"<p>Under <code>formatters.graphviz.hidden_layers</code> you can define a list of <code>layers</code> you do not want to include when using the corresponding <code>graphviz</code> output formatter. The generated image will not contain these layers, but they will be part of the analysis.</p> <p>There are 2 main use-cases for this feature:</p> <ul> <li>Hiding a generic/general domains like the <code>vendor</code> folder</li> <li>Having multiple \"views\" for your architecture. You can define a shared file   with all your <code>layers</code> and a <code>ruleset</code> and then have multiple config files for   the different <code>hidden_layers</code>. Using the <code>graphviz</code> formatter with these files   will then generate graphs focusing on only the relevant layers.</li> </ul> <pre><code>deptrac:\n  layers:\n    -\n      name: Utils\n      collectors:\n        -\n          type: classLike\n          value: .*Util.*\n    -\n      name: Controller\n      collectors:\n        -\n          type: classLike\n          value: .*Controller.*\n  ruleset:\n    Controller:\n      - Utils\n  formatters:\n    graphviz:\n      hidden_layers:\n        - Utils\n</code></pre>"},{"location":"formatters/#group-layers","title":"Group layers","text":"<p>Another supported option is <code>formatters.graphviz.groups</code>. There you can sort layers into groups that will be rendered as sub-graphs in GraphViz output.</p> <p>The following config:</p> <pre><code>deptrac:\n  layers:\n    - User Frontend\n    - User Backend\n    - Admin Frontend\n    - Admin Backend\n  formatters:\n    graphviz:\n      groups:\n        User:\n          - User Frontend\n          - User Backend\n        Admin:\n          - Admin Frontend\n          - Admin Backend\n</code></pre> <p>Will produce the following graph:</p> <p></p>"},{"location":"formatters/#pointing-to-groups-instead-of-nodes","title":"Pointing to groups instead of nodes","text":"<p>With <code>formatters.graphviz.pointToGroups</code> set to <code>true</code>, when you have a node inside a groups with the same name as the group itself, edges pointing to that node will point to the group instead. This might be useful for example if you want to provide a \"public API\" for a module defined by a group.</p>"},{"location":"formatters/#mermaidjs-formatter","title":"MermaidJS Formatter","text":"<p>The MermaidJS formatter is a console formatter, which generates a mermaid.js compatible graph definition. It can be activated with <code>--formatter=mermaidjs</code>. With the -o option you can specify the output file.</p> <p>Available options:</p> <p><pre><code>--formatter=mermaidjs\n--output= path to a dumped file\n</code></pre> With this example Yaml Config:</p> <pre><code>deptrac:\n  layers:\n    - User Frontend\n    - User Backend\n    - Admin Frontend\n    - Admin Backend\n  formatters:\n    mermaidjs:\n      direction: TD\n      groups:\n        User:\n          - User Frontend\n          - User Backend\n        Admin:\n          - Admin Frontend\n          - Admin Backend\n</code></pre> <p>This will produce the following graph:</p> <pre><code>flowchart TD;\n  subgraph ContractGroup;\n    Contract;\n  end;\n  subgraph SupportiveGroup;\n    Supportive;\n    File;\n  end;\n  subgraph SymfonyGroup;\n    Console;\n    DependencyInjection;\n    OutputFormatter;\n  end;\n  subgraph CoreGroup;\n    Analyser;\n    Ast;\n    Dependency;\n    InputCollector;\n    Layer;\n  end;\n    Contract --&gt;|6| Symfony;\n    InputCollector --&gt;|3| File;\n    InputCollector --&gt;|7| Symfony;\n    Dependency --&gt;|36| Ast;\n    Layer --&gt;|68| Ast;\n    Layer --&gt;|8| Symfony;\n    Analyser --&gt;|18| Ast;\n    Analyser --&gt;|23| Dependency;\n    Analyser --&gt;|6| Layer;\n    Analyser --&gt;|10| Symfony;\n    Ast --&gt;|3| Symfony;\n    Ast --&gt;|3| InputCollector;\n    Ast --&gt;|7| File;\n    OutputFormatter --&gt;|5| Symfony;\n    OutputFormatter --&gt;|1| DependencyInjection;\n    File --&gt;|9| Symfony;\n    DependencyInjection --&gt;|37| Symfony;\n    Console --&gt;|66| Symfony;\n    Console --&gt;|2| DependencyInjection;\n    Console --&gt;|16| Analyser;\n    Console --&gt;|5| File;\n    Console --&gt;|4| OutputFormatter;\n    Console --&gt;|4| Time;\n</code></pre>"},{"location":"formatters/#json-formatter","title":"JSON Formatter","text":"<p>By default, Json formatter dumps information to STDOUT. It can be activated with <code>--formatter=json</code></p> <pre><code>{\n  \"Report\": {\n    \"Violations\": 1,\n    \"Skipped violations\": 2,\n    \"Uncovered\": 1,\n    \"Allowed\": 0,\n    \"Warnings\": 0,\n    \"Errors\": 0\n  },\n  \"files\": {\n    \"src/ClassA.php\": {\n      \"violations\": 2,\n      \"messages\": [\n        {\n          \"message\": \"ClassA must not depend on ClassB (LayerA on LayerB)\",\n          \"line\": 12,\n          \"type\": \"error\"\n        },\n        {\n          \"message\": \"ClassA should not depend on ClassC (LayerA on LayerB)\",\n          \"line\": 15,\n          \"type\": \"warning\"\n        }\n      ]\n    },\n    \"src/ClassC.php\": {\n      \"violations\": 1,\n      \"messages\": [\n        {\n          \"message\": \"ClassC should not depend on ClassD (LayerA on LayerB)\",\n          \"line\": 10,\n          \"type\": \"warning\"\n        }\n      ]\n    },\n    \"src/OriginalA.php\": {\n      \"violations\": 1,\n      \"messages\": [\n        {\n          \"message\": \"OriginalA has uncovered dependency on OriginalB (LayerA)\",\n          \"line\": 5,\n          \"type\": \"warning\"\n        }\n      ]\n    }\n  }\n}\n</code></pre> <p>Supported options:</p> <pre><code>--output= path to a dumped json file\n</code></pre>"},{"location":"formatters/#junit-formatter","title":"JUnit Formatter","text":"<p>The JUnit formatter dumps a JUnit Report XML file, which is quite handy in CI environments. It is disabled by default, to activate the formatter just use <code>--formatter=junit</code>.</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;testsuites&gt;\n    &lt;testsuite id=\"1\"\n        package=\"\"\n        name=\"Controller\"\n        timestamp=\"2018-06-07T10:09:34+00:00\"\n        hostname=\"localhost\"\n        tests=\"3\"\n        failures=\"2\"\n        errors=\"0\"\n        time=\"0\"&gt;\n        &lt;testcase name=\"Controller-examples\\Layer1\\AnotherClassLikeAController\"\n            classname=\"examples\\Layer1\\AnotherClassLikeAController\"\n            time=\"0\"&gt;\n            &lt;failure message=\"examples\\Layer1\\AnotherClassLikeAController:5 must not depend on examples\\Layer2\\SomeOtherClass (Controller on Layer2)\"\n                type=\"WARNING\" /&gt;\n            &lt;failure message=\"examples\\Layer1\\AnotherClassLikeAController:23 must not depend on examples\\Layer2\\SomeOtherClass (Controller on Layer2)\"\n                type=\"WARNING\" /&gt;\n        &lt;/testcase&gt;\n    &lt;/testsuite&gt;\n    &lt;testsuite id=\"2\"\n        package=\"\"\n        name=\"Layer2\"\n        timestamp=\"2018-06-07T10:09:34+00:00\"\n        hostname=\"localhost\"\n        tests=\"3\"\n        failures=\"4\"\n        errors=\"0\"\n        time=\"0\"&gt;\n        &lt;testcase name=\"Layer2-examples\\Layer2\\SomeOtherClass2\"\n            classname=\"examples\\Layer2\\SomeOtherClass2\"\n            time=\"0\"&gt;\n            &lt;failure message=\"examples\\Layer2\\SomeOtherClass2:5 must not depend on examples\\Layer1\\SomeClass2 (Layer2 on Layer1)\"\n                type=\"WARNING\" /&gt;\n            &lt;failure message=\"examples\\Layer2\\SomeOtherClass2:17 must not depend on examples\\Layer1\\SomeClass2 (Layer2 on Layer1)\"\n                type=\"WARNING\" /&gt;\n        &lt;/testcase&gt;\n        &lt;testcase name=\"Layer2-examples\\Layer2\\SomeOtherClass\"\n            classname=\"examples\\Layer2\\SomeOtherClass\"\n            time=\"0\"&gt;\n            &lt;failure message=\"examples\\Layer2\\SomeOtherClass:5 must not depend on examples\\Layer1\\SomeClass (Layer2 on Layer1)\"\n                type=\"WARNING\" /&gt;\n            &lt;failure message=\"examples\\Layer2\\SomeOtherClass:17 must not depend on examples\\Layer1\\SomeClass (Layer2 on Layer1)\"\n                type=\"WARNING\" /&gt;\n        &lt;/testcase&gt;\n    &lt;/testsuite&gt;\n&lt;/testsuites&gt;\n</code></pre> <p>Supported options:</p> <pre><code>--output=     path to a dumped xml file [default: \"./junit-report.xml\"]\n</code></pre>"},{"location":"formatters/#table-formatter","title":"Table Formatter","text":"<p>The default formatter is the table formatter, which groups results by layers to its own table. It can be also activated with <code>--formatter=table</code>.</p>"},{"location":"formatters/#codeclimate-formatter","title":"Codeclimate Formatter","text":"<p>By default, Codeclimate formatter dumps information to STDOUT. It can be activated with <code>--formatter=codeclimate</code></p> <p>This formatter is compatible with GitLab CI.</p> <p>Supported options:</p> <pre><code>--output= path to a dumped file\n</code></pre>"},{"location":"formatters/#change-severity-of-a-violation","title":"Change severity of a violation","text":"<p>Under <code>formatters.codeclimate.severity</code> you can define which severity string you want to assign to a given violation type. By default, deptrac uses <code>major</code> for failures, <code>minor</code> for skipped violations and <code>info</code> for uncovered dependencies.</p> <pre><code>deptrac:\n  formatters:\n    codeclimate:\n      severity:\n        failure: blocker\n        skipped: minor\n        uncovered: info\n</code></pre>"},{"location":"formatters/#example-issue-raport","title":"Example issue raport","text":"<pre><code>[\n  {\n    \"type\": \"issue\",\n    \"check_name\": \"Dependency violation\",\n    \"fingerprint\": \"3c6b66029bacb18446b7889430ec5aad7fae01cb\",\n    \"description\": \"ClassA must not depend on ClassB (LayerA on LayerB)\",\n    \"categories\": [\"Style\", \"Complexity\"],\n    \"severity\": \"major\",\n    \"location\": {\n      \"path\": \"ClassA.php\",\n      \"lines\": {\n        \"begin\": 12\n      }\n    }\n  }\n]\n</code></pre>"},{"location":"upgrade/","title":"Upgrade from 1.0.2 to 2.0.0","text":""},{"location":"upgrade/#dropped-functionality","title":"Dropped functionality","text":"<ul> <li>\"Old\" collector configurations using specific keys for each collector no longer triggers deprecation warning and no longer work. For fixes and affected collectors, see https://github.com/qossmic/deptrac/issues/800</li> <li>Config key <code>use_relative_path_from_depfile</code> was unused internally and has been dropped</li> <li>Collector <code>className</code> has been dropped. It was aliased to <code>classLike</code> internally. Going forward, use <code>classLike</code> collector instead.</li> <li><code>%depfileDirectory%</code> config variable has been dropped. use <code>%projectDirectory%</code> instead.</li> </ul>"},{"location":"upgrade/#known-bc-breaks","title":"Known BC breaks","text":"<ul> <li>Newly exceptions are now exposed in the contract (https://github.com/qossmic/deptrac/pull/1079)</li> <li>Updated result generation, changing contract signature (https://github.com/qossmic/deptrac/pull/1091)</li> <li><code>CollectorInterface</code> can now throw new exception (https://github.com/qossmic/deptrac/pull/1103/files#diff-c8a7cf839a6a42987513abd863ee41f21222cc7ea85f17b38f6ccc6c7eba384f)</li> <li>Changed output of <code>ConsoleFormatter</code> (https://github.com/qossmic/deptrac/pull/1105)</li> <li>Changed default dependency emitters from <code>CLASS_TOKEN</code> + <code>USE_TOKEN</code> to <code>CLASS_TOKEN</code> + <code>FUNCTION_TOKEN</code>. You can get the old behaviour by explicitly specifying the old emitters in your config file.</li> <li>Method <code>addWarnings</code> was removed from <code>AnalysisResult</code>. Use <code>addWarning</code> instead.</li> <li>Method <code>isViolationSkipped</code> was removed from <code>EventHelper</code>. Use <code>addSkippableViolation</code> instead.</li> </ul>"},{"location":"upgrade/#upgrade-from-020-to-021","title":"Upgrade from 0.20 to 0.21","text":""},{"location":"upgrade/#depfile-configuration-file","title":"Depfile (Configuration File)","text":"<p>In order to fix an issue where the same parameter from an imported file was being replaced instead of merged, we needed to reinstate the semantic configuration that was previously removed. We recommend switching back to semantic configuration, especially if you rely on imports.</p> <p>The following parameters can now be moved to <code>deptrac:</code>:</p> <ul> <li>paths</li> <li>exclude_files</li> <li>layers</li> <li>ruleset</li> <li>skip_violations</li> <li>formatters</li> <li>analyser</li> <li>use_relative_path_from_depfile</li> <li>ignore_uncovered_internal_classes</li> </ul> <p>The examples and documentation were updated accordingly.</p>"},{"location":"upgrade/#upgrade-from-019-to-020","title":"Upgrade from 0.19 to 0.20","text":""},{"location":"upgrade/#commands","title":"Commands","text":"<ul> <li>You must now use the new <code>--config-file</code> option instead of providing the   configuration file (Depfile) as command argument</li> </ul>"},{"location":"upgrade/#depfile-configuration-file_1","title":"Depfile (Configuration File)","text":"<ul> <li>The <code>baseline</code> parameter was removed. You can use <code>imports</code> instead.</li> <li>The <code>ruleset</code> is no longer checked for undefined layers. They will be    silently ignored instead.</li> <li>The parameter <code>use_relative_path_from_depfile</code> no longer exists. It is    replaced by a <code>projectDirectory</code> parameter, which by default points to    <code>%depfileDirectory%</code> and can be changed to <code>%currentWorkingDirectory%</code> or any    other base directory you want to use as reference for relative paths.</li> </ul>"},{"location":"upgrade/#baseline-formatter","title":"Baseline Formatter","text":"<ul> <li>The default filename created by the baseline formatter changed.     <pre><code>From: depfile.baseline.yml\nTo:   deptrac.baseline.yaml\n</code></pre> If you are not using the <code>-o|--output=</code> option, then you will end up with 2 files (old and new one) and likely import the old one in your main deptrac.yaml. You can avoid this by using the <code>-o</code> option or updating your deptrac.yaml and removing the old baseline file.</li> </ul>"},{"location":"upgrade/#upgrade-from-018-to-019","title":"Upgrade from 0.18 to 0.19","text":""},{"location":"upgrade/#depfile-configuration-file_2","title":"Depfile (Configuration File)","text":""},{"location":"upgrade/#what","title":"What?","text":"<ul> <li> <p>The location of the default configuration file has changed.</p> <pre><code>From: ./depfile.yaml\nTo:   ./deptrac.yaml\n</code></pre> </li> <li> <p>The configuration inside the file must now be nested under <code>parameters:</code>   except for imports. See docs for examples.</p> </li> </ul>"},{"location":"upgrade/#how","title":"How?","text":"<p>In your <code>depfile.yaml</code> you can just add a new section <code>parameters:</code> at the top and then indent the remaining config 1 level under this section. The only exception is <code>imports</code> which should stay on its current level and should not be nested under parameters.</p> <p>Example: From: https://github.com/qossmic/deptrac/blob/0.18.0/depfile.yaml To: https://github.com/qossmic/deptrac/blob/0.19.0/deptrac.yaml</p> <p>After that, you can rename the file to <code>deptrac.yaml</code> to avoid the displayed warning and ensure the file will automatically be loaded in future versions. Alternatively you can keep your filename and make sure you load it via the new <code>--config-file</code> option in the relevant commands instead of as an argument.</p>"},{"location":"upgrade/#why","title":"Why?","text":"<p>In the future, we want to allow adding services to the configuration to extend Deptrac's functionality, e.g. by providing custom collectors. That is why we must separate the config into dedicated sections parameters and services.</p>"},{"location":"blog/2023-05-11_PHP_configuration/","title":"Dynamic Deptrac configuration with PHP config file","text":"<p>May 11, 2023 - 5 min read</p> <p>Do you copy-paste deptrac config every time you need to add a layer? Do you have a large existing project that has similar structure across its architecture? With PHP config files you can significantly cut down the amount of time spend on creating and maintaining your deptrac configuration.</p> <p>For a long time, Deptrac was only supporting a <code>yaml</code> configuration. Thanks to the effort by grennadi you can now use Symfony config builders to create a dynamic deptrac configuration using PHP. Let's take a look at how to do it.</p> <p>Start by creating a <code>deptrac.config.php</code> file in the root of the project:</p> <pre><code>&lt;?php\n\nuse Qossmic\\Deptrac\\Contract\\Config\\DeptracConfig;\nuse Symfony\\Component\\DependencyInjection\\Loader\\Configurator\\ContainerConfigurator;\n\nreturn static function (DeptracConfig $config, ContainerConfigurator $containerConfigurator): void {\n\n};\n</code></pre> <p>All the required classes you might need for config definition exist in the <code>Qossmic\\Deptrac\\Contract\\Config</code> namespace and are covered by the backwards compatibility promise, so you don't need to worry your configuration will suddenly stop working without warning.</p> <p>Then define the shared configuration for the project like <code>paths</code> to the analysed files and the used <code>analysers</code>:</p> <pre><code>    $config\n        -&gt;paths('src')\n        -&gt;analysers(\n            EmitterType::CLASS_TOKEN,\n            EmitterType::FUNCTION_TOKEN,\n            EmitterType::FUNCTION_CALL,\n        );\n</code></pre> <p>Continue by defining some layers:</p> <pre><code>    $config\n        -&gt;layers(\n            $dependency = Layer::withName('Dependency')-&gt;collectors(\n                DirectoryConfig::create('src/Core/Dependency/.*')\n            ),\n            $dependencyInjection = Layer::withName('DependencyInjection')-&gt;collectors(\n                DirectoryConfig::create('src/Supportive/DependencyInjection/.*')\n            ),\n            $inputCollector = Layer::withName('InputCollector')-&gt;collectors(\n                DirectoryConfig::create('src/Core/InputCollector/.*')\n            ),\n            $layer = Layer::withName('Layer')-&gt;collectors(\n                DirectoryConfig::create('src/Core/Layer/.*')\n            ),\n            $file = Layer::withName('File')-&gt;collectors(\n                DirectoryConfig::create('src/Supportive/File/.*')\n            ),\n        );\n</code></pre> <p>You can use all the collectors you find in the collectors' documentation. Use the appropriate config class in the  <code>Qossmic\\Deptrac\\Contract\\Config\\Collector\\</code> namespace.</p> <p>Notice that we assign all the layer configs to a variable. This is important to define rulesets between the layers:</p> <pre><code>    $config\n        -&gt;rulesets(\n            Ruleset::forLayer($inputCollector)-&gt;accesses($file),\n            #...\n        );\n</code></pre> <p>You can also define configuration for the formatters if you need to, again re-using the previously defined layers to ensure you don't have a typo in your definition:</p> <pre><code>    $config\n        -&gt;formatters(\n            GraphvizConfig::create()\n                -&gt;pointsToGroup(true)\n                -&gt;groups('Supportive', $file, $dependencyInjection)\n                -&gt;groups('Core', $dependency, $inputCollector, $layer)\n        );\n</code></pre> <p>Last, but not least, you can also plug in any extension you write like custom collectors, rules or commands. For example a custom suppression of violations when depending on contract classes:</p> <pre><code>    $services = $containerConfigurator-&gt;services();\n    $services-&gt;set(IgnoreDependenciesOnContract::class)\n        -&gt;tag('kernel.event_subscriber');\n</code></pre> <p>To tie it all together, you have to specify that you want deptrac to you your php config file, for example like this:</p> <pre><code>$ php deptrac.php -c deptrac.config.php\n</code></pre> <p>As you can see this feature allows you to use the full expressive power of PHP to create dynamic configuration on the fly.</p> <p>Do you like Deptrac and use it every day? Consider supporting further development of Deptrac by sponsoring me on GitHub Sponsors. I\u2019d really appreciate it!</p> <p>Author: patrickkusebauch</p>"}]}